# JS面试问答 - 基础篇

## 原型与原型链

在js中一切都是对象，对象是使用相应的原型生成而来的。每个对象通过prototype指针连接原型对象，原型对象又通过constructor指针连接对象，相互引用

设计原型就是为了共享属性和方法。在调用属性和方法的时候，会先从对象自身查找，如果找不到就会去其原型查找，由于原型本身也是一个对象，还找不到的话就会查找原型的原型，找到就会调用，如果到达顶端，也就是Object的原型依旧没找到的话，就会抛出错误。这样就形成了一条链，使用__proto__属性把原型连接起来，就是原型链

然后可以引申到继承

## 继承

实现继承有两个方面要考虑，原型属性和方法的继承，还有就是构造器的继承


## 什么是闭包

因为函数作用域的原因，函数外无法引用函数内部的变量。为了使用这个变量，就可以在函数内部return一个新的函数。函数里面返回这个变量。这种情况就叫做闭包，但这样会保持对该变量的引用，导致变量不会被垃圾回收机制回收，从而容易造成内存泄漏


TODO 这里加一个柯里化的连接，手写代码的地方会有

函数的柯里化依赖于闭包来记住之前传递的参数，立刻执行函数本质上也是一种闭包


## promise

异步的解决方案，将异步封装成一个promise对象。有三个状态：进行中、成功和失败。状态只会改变一次，用then来获取异步的结果。catch来捕获错误。finally则是最后执行

有几个静态方法：all、any、allSettle、race

除了catch，还可以用try...catch来进行错误捕获

阻止链式调用的方法：返回一个为决议的新promise对象，then就会一直等待。但并不推荐



## es6数组新特性

扩展运算符、Symbol.iterator属性，指向一个迭代器方法，可以用for of来遍历属性，还有以下api

- from
- find、findIndex
- fill
- includes
- flat
- entries
- keys / values


## 箭头函数和普通函数

除了定义方法外，箭头函数没有自己独立的this，所以不能用作构造函数，不能使用new关键字。其他与普通函数没有区别

箭头函数的this始终指向上下文中的this

## for of和for in的区别

of会在可迭代对象上创建一个迭代器，然后遍历迭代器返回的每个元素，直到被遍历完。in则用于遍历对象的可枚举属性，包括从原型链继承来的属性


## 防抖和节流

都用来执行函数被频繁调用的情况。

防抖函数的实现原理是使用 `setTimeout` 函数来延迟执行事件处理函数，并使用闭包保存 `setTimeout` 返回的定时器标识。如果在延迟时间内再次触发同一个事件，则清除之前的定时器，并重新设置定时器。

节流函数则是在一个时间段内只能执行一次函数，也是通过定时器。在定时器时间内再次调用不会执行

防抖可以用在搜索框搜索输入、调整窗口大小、表单验证等。节流可以用在滚动事件、按钮点击等

## 并发与并行

并发是多个任务在同一时间段内同时执行，但不一定同时开始或结束。并行则是在同一时刻同时执行。所以在js中，讨论更多的是并发。也可以使用web workers来实现一定程度的并行


## 函数柯里化

可以用于简化参数量，可以把多个参数的函数转换成单参数的函数

## 检测数据类型的方法

- typeof
- Array.isArray
- Object.prototype.toString.call()
- instanceof

## set map weakset weakmap的区别

set可以储存任何类型的值，map则是键可以为任何类型

- set：一种集合数据结构，用于储存唯一值
  - add添加，has查询，delete删除，clear删除所有，values返回一个新的迭代器对象
- map：用于保存键值对，可以记住键的插入顺序
  - set接受两个参数，分别是键和值，用于添加，get查询，delete删除，clear删除所有
- weakset：类似于set，但只能储存对象引用，不能储存原始值
- weakmap：键只能是对象，值可以任意

## proxy 与 object.defineproperty

proxy用于创建一个对象的代理，从而实现基本操作的自定义行为。相比于defineproperty是一种更强大的定制对象的方式

object.defineproperty则是es5的，允许精准的添加或修改对象属性，并为其提供getter和setter方法

## 继承的几种方式

- 原型继承
- 构造函数继承
- class的extends关键字
- 原型和构造函数的组合继承

## 作用域链

在使用变量时候，会先查找自身的作用域，找不到就往上找，直到全局作用域。被链接起来的就是作用域链，通过[[scope]]指针，但只能从下往上进行查找


## 深浅拷贝是什么，区别在于什么

浅拷贝只拷贝对象的指针，新旧对象共用同一块内存。深拷贝则是完全创建一个新对象

常用的浅拷贝方法

- 对象方法：`Object.assign()`，该方法接收多个参数，第一个参数是目标对象，其余则是来源对象。但使用该方法进行拷贝有一些限制，比如不会拷贝对象的继承属性、不会拷贝对象的不可枚举属性等。但可以拷贝`symbol`类型的属性，但对象只有一层的时候，是深拷贝
- 扩展运算符：`let cloneObj = {...obj}`
- 拷贝一维数组：`arr.slice()`

常见的深拷贝则是 JSON.stringify 和 JSON.parse 合用，对键为函数和symbol的时候，这个键值对会消失。日期对象会变成字符串。无法拷贝不可枚举的属性和原型链


## 事件循环

因为js是单线程的，运行在渲染主线程中，所以会有阻塞问题。事件循环就是用于解决阻塞的。对异步的任务进行调度。浏览器将异步的任务分为宏任务和微任务

浏览器会先执行同步的任务，然后把异步任务放入事件循环的队列中，同步任务执行结束后，再从队列中取异步任务。

事件队列会先执行一个宏任务，然后执行宏任务所产生的微任务，直到所有都执行完毕，在进行下一个宏任务

常见的宏任务有定时器，io相关内容还有UI的渲染。微任务的话就是promise.then等


## class类相关的

有自己构造器，new调用的时候先执行构造器，可以继承，可以设置私有变量和静态函数。静态函数通过static来进行定义，只能类自己调用，实例无法调用。静态变量则通过#来进行定义，只能在类内部使用


## aync await generater

处理异步的方法，可以把异步看起来更像同步的写法。async标记的函数返回的一定是promise，await等待的也是promise

generator则是一个生成器，可迭代协议的一种表现。使用Symbol.iterator作为键来定义可迭代器



迭代器通过在函数名前标记*来定义，在函数中通过yeild来进行暂停，可以使用next方法来进行逐个遍历，返回value和done的对象




## 对象的继承

原型继承，

## 取消已发送的ajax请求

- xhr.abort()

```js
// 创建axios实例
const axios = require('axios');

// 创建一个CancelToken源
const CancelToken = axios.CancelToken;
let cancel;

axios.get('https://api.example.com/data', {
  cancelToken: new CancelToken(function executor(c) {
    // 这个executor函数接收一个cancel函数作为参数
    cancel = c;
  })
})
.then(response => {
  console.log(response);
})
.catch(error => {
  if (axios.isCancel(error)) {
    console.log('Request canceled', error.message);
  } else {
    // 处理错误
  }
});

// 取消请求 (请求的消息是可选的)
cancel('Operation canceled by the user.');
```

## 数组的清空方法

- 直接赋值长度为0
- splice
- 覆盖原数组
- 判断数组

## 数组相关，改变自身

## 回调地狱的try...catch和错误捕获

异步函数需要在函数内部处理错误，因为try-catch只能捕获同步代码的错误。因为try-catch是同步的

但async的函数可以通过try-catch来进行错误捕获


## new URL()


用于创建一个URL对象，它提供了解析和构建URL的便利方法

```js
let url = new URL('https://www.example.com/path?query=123#hash');

console.log(url.hostname); // 'www.example.com'
console.log(url.pathname); // '/path'
console.log(url.searchParams.get('query')); // '123'
console.log(url.hash); // '#hash'
```

## 浏览器缓存

浏览器缓存主要分为以下几种类型：

- 强缓存：通过设置HTTP响应头中的Cache-Control或Expires来控制。如果资源未过期，浏览器将直接从缓存中读取资源，而不会向服务器发送请求
- 协商缓存：通过Last-Modified/If-Modified-Since和ETag/If-None-Match实现。浏览器会发送一个条件性请求到服务器，服务器决定是否使用缓存的资源
- 缓存存储机制：包括内存缓存和硬盘缓存。内存缓存响应速度快但持续时间短，而硬盘缓存速度较慢但数据可以持久保存。


## 对称加密和非对称加密的优缺点


对称加密和非对称加密是两种不同的加密方式。

对称加密指的是加密和解密使用的是同一个密钥的加密方式，加密速度快，但密钥管理较为困难，安全性相对较低。常见的对称加密算法有DES、3DES、AES等。

非对称加密指的是加密和解密使用的是不同的密钥的加密方式，一般称为公钥加密和私钥解密。公钥可以公开，而私钥只有密钥的持有者才能使用，安全性相对较高。常见的非对称加密算法有RSA、ECC等。

对称加密和非对称加密各有优缺点，具体如下：

对称加密的优点：
- 加密和解密速度较快，适用于大量数据加密；
- 加密解密使用同一个密钥，加密效率高。

对称加密的缺点：
- 密钥管理较为困难，需要安全地分发密钥，密钥容易被窃取；
- 无法实现公开密钥加密和数字签名等功能，安全性较低。

非对称加密的优点：
- 安全性较高，密钥管理相对较为简单，不需要安全地分发密钥；
- 可以实现公开密钥加密和数字签名等功能。

非对称加密的缺点：
- 加密解密速度较慢，不适用于大量数据加密；
- 密钥长度较长，传输的数据量相对较大。


