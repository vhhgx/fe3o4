# HTML & CSS 基础问答题

## BFC 是什么

块级格式化上下文，是一块独立的渲染区域。

**触发 BFC 的条件**

- float 非 none
- position 为 absolute 或 fixed
- display 为 flex 或 inline-block

## 事件冒泡是什么，如何阻止

可以使用 event.stopPropagation() 来阻止事件冒泡

事件委托和事件冒泡是 JavaScript 中处理 DOM 事件的两个重要概念，特别是在动态内容或大量元素的情况下。

### 事件冒泡（Event Bubbling）

事件冒泡是 DOM 事件处理的一种机制，其中从发生事件的元素（目标元素）开始，事件会逐级向上传递至最外层的父元素。这意味着，当你在一个 DOM 元素上触发事件（如点击一个按钮），这个事件不仅仅在该元素上被触发，而是沿着 DOM 树向上“冒泡”直到根元素（通常是`document`对象）。

例如，如果你有一个嵌套的列表结构，点击一个列表项（`<li>`）会首先在这个`<li>`上触发点击事件，然后是它的父元素（如`<ul>`），接着是更上层的元素，依此类推。

### 事件委托（Event Delegation）

事件委托是一种利用事件冒泡原理来优化事件处理的技术。而不是在每个子元素上单独设置事件监听器，你可以在它们的共同父元素上设置一个事件监听器，并根据事件的目标元素（`event.target`）来判断如何响应。这意味着，无论有多少子元素，你只需要在父元素上附加一个事件监听器。

例如，如果你有一个列表，并且希望对每个列表项的点击进行响应，你可以在列表（`<ul>`或`<ol>`）上设置一个点击事件监听器，而不是在每个列表项（`<li>`）上分别设置。

### 从父到子的事件传播：事件捕获（Event Capturing）

相对于事件冒泡，还有一种事件传播机制称为事件捕获。在事件捕获阶段，事件从根节点开始，沿着 DOM 树向下传递到目标元素。这意味着事件首先在最外层的父元素上被捕获，然后逐层向下，直到达到触发事件的目标元素。

事件捕获是在 DOM 事件流的早期阶段发生的，它的目的是在事件到达目标之前就能够截获它。在实际应用中，事件捕获不如事件冒泡常用，但在某些特定的交互设计中，它可以提供更细粒度的事件处理控制。

在添加事件监听器时，你可以通过设置监听器的第三个参数（`useCapture`）来指定监听器是在捕获阶段还是冒泡阶段触发。默认情况下，这个参数为`false`，表示监听器会在冒泡阶段触发。

```javascript
element.addEventListener('click', handler, true) // 在捕获阶段触发
element.addEventListener('click', handler, false) // 在冒泡阶段触发（默认）
```

了解这些概念对于编写有效且高效的事件处理代码非常重要。

## 如何解决 margin 塌陷

## 渲染什么情况会阻塞

浏览器在渲染页面时，可能会出现阻塞（Blocking）的情况，即在某些情况下，浏览器会停止页面渲染，等待某个操作完成后再继续渲染。以下是一些常见的阻塞情况：

1. CSS 和 JavaScript 文件的下载和解析：当浏览器下载和解析 CSS 和 JavaScript 文件时，会阻塞页面的渲染。这是因为浏览器在解析 CSS 和 JavaScript 文件时，需要等到这些文件下载完成、解析完成后，才能继续进行渲染。
2. 阻塞的 JavaScript 执行：当页面中的 JavaScript 执行时间过长时，会导致页面的渲染被阻塞。这是因为 JavaScript 代码执行时，会占用主线程，如果 JavaScript 代码执行时间过长，就会导致页面渲染的阻塞。
3. 大量的 DOM 操作：当页面中进行大量的 DOM 操作时，会导致页面的渲染被阻塞。这是因为 DOM 操作会引起页面的重新渲染和重排，如果进行过多的 DOM 操作，就会导致页面的渲染被阻塞。
4. 图像的下载和解码：当页面中包含大量的图像时，会导致图像的下载和解码也成为页面渲染的瓶颈。如果图像的下载和解码时间过长，就会导致页面的渲染被阻塞。
5. 使用了阻塞渲染的 CSS 属性：某些 CSS 属性会阻塞页面的渲染，例如 `position: fixed` 和 `width: calc()` 等。如果过多地使用这些阻塞渲染的 CSS 属性，也会导致页面的渲染被阻塞。

为了避免页面渲染被阻塞，我们可以采取以下措施：

1. 将 CSS 和 JavaScript 文件放在页面的底部，避免在页面渲染时阻塞主线程。
2. 尽量减少 JavaScript 代码的执行时间，可以通过代码优化、异步加载等方式来实现。
3. 减少 DOM 操作的次数，可以通过批量操作、使用虚拟 DOM 等方式来实现。
4. 使用合适的图像格式和压缩率，减少图像的下载和解码时间。
5. 避免使用阻塞渲染的 CSS 属性，尽量使用非阻塞渲染的属性。

总的来说，了解页面渲染的阻塞情况，可以帮助我们更好地优化页面性能，提高用户体验。

## 盒模型

- 标准盒模型（Content-Box）：在这个模型中，元素的总宽度和高度是由内容的宽度和高度、内边距（padding）、边框（border）和外边距（margin）共同决定的。
- IE 盒模型（Border-Box）：在这个模型中，元素的宽度和高度直接包括内容、内边距和边框，但不包括外边距
- 使用 box-sizing 去设置

## 页面导入样式时，使用 link 和@import 有什么区别

写法上：

```html
<link rel="stylesheet" href="路径" />

<style type="text/css">
  @import '路径';
</style>
```

本质上：link 属于 XHTML 标签，除了加载 css 之外，还能定义 RSS，定义 rel 连接属性等作用。而@import 是 css 提供的，只能用于加载 css
解析上：link 是跟着页面加载同时加载的，但是@import 会等到页面加载完再加载

## 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？

常见的行内元素有：a，b，span，img（我曾以为是 block），input，strong，select
常见的块级元素有：div、ul（无序）、ol（有序）、li、p 等
常见的空元素：`<br><hr><link><script>`
空元素定义：html 元素的内容就是其两个标签之间的 content，所以，标签之间没有内容的就是空元素

## 对 html 语义化的理解（了解）

用正确的标签做正确的事情。
html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析
搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

## 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。

cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。

存储大小：

cookie 数据大小不能超过 4k。
sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。

有期时间：

localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
sessionStorage 数据在当前浏览器窗口关闭后自动删除。
cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭

## iframe 有那些缺点？

- iframe 会阻塞主页面的 Onload 事件；
- 搜索引擎的检索程序无法解读这种页面，不利于 SEO
- iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
- 使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript
- 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。
- iframe 会阻塞主页面的 Onload 事件

## Label 的作用是什么？是怎么用的？

用来关联某个标签，可以是表单标签，也可以是 button，这样就可以直接点击 label 的范围来触发绑定标签的事件

## HTML5 的 form 如何关闭自动完成功能？

自动完成：当你给输入框输入内容时，浏览器会从之前同名输入框的历史记录中查找出类似的内容并列在输入框下面。
给 form 或者该 input 设置 autocomplete=off。
经过实验，提交之后，历史记录才会存储，当然，必须是 name 相同的 input 才会共享历史记录

## ::before 和 ::after 中双冒号和单冒号有什么区别、作用（伪类和伪元素的区别）？

区别：

- 在 CSS 中 伪类 一直用 : 表示，如:hover、:active 等；
- 伪元素在 CSS1 中已经存在，当时语法是用 : 表示，如:before、:after，后来在 CSS3 中修订， 伪元素 使用 :: 表示，如- ::before、::after（单冒号的写法依然可以生效）；
- 单冒号（:）用于 CSS3 的伪类；
- 双冒号（::）用于 CSS3 的伪元素；
- 想让插入的内容出现在其他内容的前面，使用::before，否则使用:after；
- 在代码顺序上，::after 生成的内容也比::before 生成的内容靠后；

作用：

- ::before 和 ::after 的主要作用是在元素内容的前后加上指定内容；
- 伪类 于 伪元素 都是用于向选择器加特殊效果；
- 伪类 于 伪元素 的 本质区别在于是否抽象的创建了新的元素；
- 伪类 只要 不是互斥 的就可以 叠加使用；
- 伪元素在一个选择器中只能出现一次，并且不能出现在开始和末尾；
- 伪类优先级 === 类优先级；
- 伪元素优先级 === 标签优先级；

---

### 为何使用 rem 单位的网站字体会随页面宽度增大而放大，该如何避免此现象？

当使用 `rem` 作为字体大小的单位时，字体大小是相对于根元素（即 HTML 元素）的字体大小的。如果根元素的字体大小与视口宽度挂钩，那么当视口宽度变化时，使用 `rem` 单位的字体大小也会相应变化。

为了避免这种情况，你可以采取以下几种方法：

1. **固定根元素字体大小**：在 CSS 中直接为根元素设置一个固定的字体大小，例如：

```css
html {
  font-size: 16px;
}
```

这样，无论视口宽度如何变化，使用 `rem` 单位的元素字体大小都不会改变。

2. **使用媒体查询来控制根元素字体大小**：如果你想在不同的屏幕尺寸下有不同的字体大小，但又不想它随着窗口的拉伸而持续变化，可以使用媒体查询来为不同的屏幕宽度设置不同的根元素字体大小。例如：

```css
html {
  font-size: 16px;
}

@media (min-width: 600px) {
  html {
    font-size: 18px;
  }
}

@media (min-width: 1000px) {
  html {
    font-size: 20px;
  }
}
```

这样，在不同的断点下，你可以控制字体的大小，但在断点之间字体大小不会变。

3. **避免在根元素上使用百分比或视窗单位**：有时候，根元素的字体大小可能被设置为相对于视窗的宽度的一个百分比（如 `vw` 单位）。这会导致字体大小随着视窗宽度的变化而变化。避免使用这样的单位可以防止 `rem` 单位的字体大小随之变化。

通过这些方法，你可以有效控制使用 `rem` 单位的元素的字体大小，使其不会随着页面宽度的变化而变化。

- parent 元素宽高不定，实现 scale 固定宽高比始终为 4：3
- 一些 css 动画
- 垂直居中的几种方案

CSS 重叠样式表，重叠怎么理解
Vue 的 diff 和 React 的 diff 有什么不同
虚拟 Dom 是什么，为什么要用虚拟 Dom
为什么很多框架采用无虚拟 Dom，例如 svelte
为什么浏览器只有 body 在界面展示，head 这部分在浏览器中是什么处理的
如果后端一直返回数据，需要对 table 进行数据展示要怎么来设计，需要考虑内存储存不够场景
css 动画为什么比 js 动画流畅
怎么实现组件库的整体引用和分别引用，对于 css 样式怎么来实现呢？
Vue 为什么有静态提升
