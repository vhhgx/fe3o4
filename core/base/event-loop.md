# 事件循环

## 简述

### 产生原因

JS是一个单线程的语言，运行在浏览器的渲染主线程中，所以会有阻塞问题。如果有无法立即执行的任务会导致主线程阻塞，导致浏览器卡死。而事件循环则负责对任务进行调度

渲染主线程负责解析html、css，计算样式和布局（元素位置、宽高等），处理图层和执行JS等


### $补充内容

浏览器分成了多个线程，一个负责程序本身的运行，成为主线程，一个则就是事件线程，还有很多其他线程

在es6中，微任务叫做jobs，宏任务为task

### 执行逻辑




在代码运行时，会先执行立即执行的任务。如果无法立即执行，浏览器则会将其放置在事件循环队列中。等待所有同步任务执行结束之后，主线程将从事件循环队列中取相应的任务进行执行。**无法立即执行的** 任务如下

- `宏` setTimeout / setInterval
- `宏` 整体的代码
- `宏` IO
- `宏` UI渲染
- 
- XHR / Fetch
- addEventListener
- `微` Process.nextTick（Nodejs
- `微` Promise.then
- `微` MutationObserve

早些版本的浏览器会将异步任务分成宏任务和微任务，微任务的优先级高于宏任务。新版浏览器则没有这一区分，任务没有优先级，但队列有。队列的优先级**从高到低**依次为

- 微任务队列
- 交互队列（交互、操作、事件相关）
- 计时队列
- 其他队列

需要注意new Promise会进入到主线程中立刻执行，而promise.then则属于微任务

在每次事件循环执行时，宏任务和微任务会按照不同的优先级分别被执行，它们的执行顺序如下：

1. 执行一个宏任务。
2. 执行该宏任务产生的微任务，直到微任务队列为空。
3. 进入下一个宏任务，重复上述步骤。

## 常见面试问题

主要与计时器和Promise结合


### 计时器

如果在执行中遇到了计时器，主线程的执行顺序如下：

1. 将计时任务丢到计时队列中
2. 计时过程中，主线程继续执行其他任务
3. 计时结束，将计时器放置到事件队列中
4. 等待队列其他任务结束之后，执行计时器的回调

如果计时器的时间设置为0mm，也依然会将其放置在事件队列中



如何理解“在浏览器中，每个宏任务中的微任务队列是独立的”
assistant: 在浏览器中，每个宏任务都有一个独立的微任务队列，也就是说，当一个宏任务执行过程中产生了多个微任务时，这些微任务会被添加到该宏任务的独立微任务队列中。这样做的好处是可以保证在一个宏任务执行完成之前，其产生的所有微任务都能被执行完毕，从而避免了微任务之间相互干扰的问题。

举个例子，假设我们有如下代码：

```javascript
setTimeout(() => {
  console.log('setTimeout')
}, 0)

Promise.resolve().then(() => {
  console.log('promise')
})
```

在这段代码中，`setTimeout` 产生的任务属于一个宏任务，而 `Promise.resolve().then()` 产生的任务属于一个微任务。当这两个任务都被添加到任务队列中之后，它们就开始等待事件循环机制的执行。在事件循环执行过程中，当宏任务队列中的 `setTimeout` 任务被执行时，它会产生一个独立的微任务队列，并将其中的 `console.log('setTimeout')` 任务添加到该队列中。此时，如果在 `setTimeout` 任务执行期间，产生了新的微任务，那么这些微任务会被添加到刚刚创建的独立微任务队列中，而不会被添加到其他宏任务的微任务队列中。

这种设计可以保证微任务的执行顺序和优先级，避免了微任务之间的相互影响，从而确保了异步编程的正确性和可靠性。
user: 没看懂，可以结合代码更详细说明嘛
assistant: 好的，那我结合代码来详细说明一下。

我们先来看下面这段代码：

```javascript
setTimeout(() => {
  console.log('setTimeout 1')
  Promise.resolve().then(() => {
    console.log('promise 1')
  })
  Promise.resolve().then(() => {
    console.log('promise 2')
  })
}, 0)

setTimeout(() => {
  console.log('setTimeout 2')
}, 0)
```

这段代码中，我们使用了两个 `setTimeout`，分别将两个任务添加到宏任务队列中，同时在第一个任务中使用了两个 `Promise.resolve().then()`，将两个任务添加到了同一个宏任务的微任务队列中。

运行这段代码后，输出的结果如下：

```
setTimeout 1
promise 1
promise 2
setTimeout 2
```

可以看到，先输出了第一个 `setTimeout`，然后依次输出了该宏任务的两个微任务 `promise 1` 和 `promise 2`，最后输出了第二个 `setTimeout`。

这个输出结果就说明了每个宏任务的微任务队列是独立的。当第一个 `setTimeout` 任务执行时，它首先会执行自己的同步代码，然后创建一个独立的微任务队列，并将两个 `Promise.resolve().then()` 的回调函数添加到该队列中。这时，即使在回调函数执行期间产生了新的微任务，这些微任务也会被添加到该独立微任务队列中，而不会被添加到其他宏任务的微任务队列中。

因此，在浏览器环境中，每个宏任务的微任务队列是独立的，这可以保证异步编程的正确性和可靠性。


### Promise

具体内容详见 [Promise - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) 和 [Promise](/core/base/promise)


