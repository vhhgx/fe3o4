# 作用域与闭包

## 执行上下文

JavaScript代码执行之前，会首先进行创建阶段。会创建变量对象和建立作用域链。其中变量对象包含了当前执行上下文中声明的所有的变量和函数，以及函数的参数。而作用域链是一个指向父级的执行上下文引用列表，用于查找变量和函数的值

创建完成后，JS引擎就会按照代码的顺序逐行执行代码。每个函数在调用时都会创建新的执行上下文，包含以下几个内容

- 变量对象
- 作用域链
- this

主要有全局和函数两种上下文，任何不在函数内部的代码都在全局执行上下文中。负责创建一个全局对象，在浏览器中是`window`，并将this指向这个全局对象

多个执行上下文通过`执行上下文栈`来进行维护，如果使用到了当前上下文变量环境不存在的变量，就会顺着作用域链向上进行查找

在创建阶段，函数声明和使用var的变量声明会被提前至所在的作用域顶部，被称为变量提升。意味着可以在声明前使用变量或者函数。但对于变量来说，只有声明本身会被提升，其他逻辑则不会


## 作用域

由于js语言现编译现执行的特性。会根据代码的先后顺序来划分不同的作用域，指定了函数和变量的作用范围。在`ES5`之前JS只有全局作用域和函数作用域。`ES6`新增了作用于花括号内部的块级作用域。函数作用域是块级作用域的子集，都属于局部作用域

此时的作用域是在代码中定义的，称作**词法作用域**或**静态作用域**

```js
var str = 'hello'

function scope() {
  var num = 20
  console.log(str, num)
}

scope()
```

运行上面的代码，会打印`hello 20`。可以看到在函数中虽没声明`str`却可以正确的进行打印。是因为JS引擎在编译过程中，会自动添加一个隐式的`[[scope]]`指针，指向其父作用域。在本例中即为全局作用域

如果在当前作用域中找不到相应的变量，就会沿着`[[scope]]`指针向上查找，直到全局。依旧找不到则会抛出错误。多个域被`[[scope]]`指针连接起来，就形成了**作用域链**。需要注意`[[scope]]`指针是单向的，只能向上进行查找，反之则会报错。《JavaScript高级程序设计》针对作用域链给出的定义是这样的：**作用域链来保证对执行环境有权访问的变量和函数的有序访问**

在全局执行上下文中，会先找`变量声明`，再找`函数声明`。而在函数执行上下文中，则先找函数的`形参`，再找函数内的`变量声明`，最后将实参赋值给形参


## 闭包

受到作用域链`[[scope]]`指针只能够向上单向查找的限制。有时候我们需要一个`函数作用域`内声明变量的值，如果直接在函数外使用编译器则会报错，比如下面一段代码


```js
function getValue() {
  let value = 'a required value'
}

console.log(value)
```

编译器会报错 *ReferenceError: value is not defined*，因为全局作用域并没有一个叫做`value`的变量。这时候闭包函数就派上了用场，红宝书《JavaScript高级程序设计》是这样定义闭包的：**引用了另一个函数作用域中变量的函数**


```js
function getValue() {
  let value = 'a required value'

  return function closure() {
    return value
  }
}

let instance = getValue()


console.log(instance()) // 打印 a required value
```

如上面的代码，`getValue()`函数作用域及其作用域链的一切变量对于`closure()`函数都是透明可见的，所以只需要将`closure()`函数返回，就可以取得作用域内新声明的变量值。此时`closure()`就是一个闭包函数

由于`getValue()`函数被赋值给了一个全局变量`instance`，就导致`instance`变量会一直存在内存中。变量所依赖的`getValue`函数也会一直保存在内存中，不会因为调用完毕而出栈被垃圾回收机制销毁。需要注意，**闭包不会造成内存泄漏，错误的使用闭包才是内存泄漏**

被闭包引用的外部作用域中的变量将一直存活直到闭包函数被销毁。如果一个变量被多个闭包所引用，那么直到所有的闭包被垃圾回收后，该变量才会被销毁。所以我们应当在不再使用的时候，手动将其删除

### 闭包的表现形式

1. 返回一个函数
2. 在定时器，事件监听，ajax请求或者异步中使用了回调函数，实际就是使用闭包
3. 作为函数参数传递的形式
4. IIFE（立即执行函数），创建了闭包。保存了全局作用域和当前函数的作用域。因此可以输出全局的变量
